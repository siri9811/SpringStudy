package com.example.firstproject.api;

import com.example.firstproject.controller.ArticleController;
import com.example.firstproject.dto.ArticleForm;
import com.example.firstproject.entity.Article;
import com.example.firstproject.repository.ArticleRepository;
import com.example.firstproject.service.ArticleService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@Slf4j
@RestController
@RequiredArgsConstructor
public class ArticleApiController {

    // @Autowired //DI, 객체를 가져와 연결
    // 필드주입 말고,
    // 2개만 추가하면 그럴싸 하게 바꿀 수 있는데,
    // @RequiredArguments머시꺵이랑
    // private final 머시기 추가하면 바로 가능
    // 잘 켜졌죠? 네네
    // 지금 문제가 두가지가 있어요 json으로 post 요청시 id없이 요청할 경우 - 기본 더미데이터 3개 넣어왔는데
    // post요청 3번은 기본키 문제로 안되고 4번부터 요청댐
    // 문제2 : id, title, content 요청시 아예 안댐
    
    // 자 봅시다
    //     create table article (
    //        id bigint generated by default as identity,
    //        content varchar(255),
    //        title varchar(255),
    //        primary key (id)
    //    )
    // 터미널에 요거 보이나요?  아 그렇구나
    // 저게JPA가 얍 하고 테이블을 만들어 줬는데, ID가 자동 생성인거 보이죠
    // 그럼 data.sql에서 id를 줘야할까요? 아님 안줘야 할까요?
    private final ArticleService articleService;

//    private ArticleRepository articleRepository;
    // GET
    @GetMapping("/api/articles")
    public List<Article> index() {
        return articleService.index();
    }
//
    @GetMapping("/api/articles/{id}")
    public Article show(@PathVariable Long id) {
        return articleService.show(id);
    }
//
    // POST
    @PostMapping("/api/articles")
    public ResponseEntity<Article> create(@RequestBody ArticleForm dto) {

        // 서비스 호출
        Article created = articleService.create(dto);

        // 로그 출력 후 응답 반환
        if (created != null) {
            log.info("Article created successfully: {}", created);
            return ResponseEntity.status(HttpStatus.OK).body(created);
        } else {
            log.error("Failed to create article"); // <--이게 터진거죠?  넵
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).build();
        }


    }


    // PATCH
    @PatchMapping("/api/articles/{id}")
    public ResponseEntity<Article> update(@PathVariable Long id, @RequestBody ArticleForm dto) {

        //
        Article updated = articleService.update(id,dto);
        return (updated != null) ?
                ResponseEntity.status(HttpStatus.OK).body(updated) :
                ResponseEntity.status(HttpStatus.BAD_REQUEST).build();
    }
    // DELETE
    @DeleteMapping("/api/articles/{id}")
    public ResponseEntity<Article> delete(@PathVariable Long id) {
        //1. 객체 생성, 삭제할 엔티티 id로 가져옴
        Article deleted = articleService.delete(id);
        return (deleted != null) ? ResponseEntity.status(HttpStatus.NO_CONTENT).build() :
        ResponseEntity.status(HttpStatus.BAD_REQUEST).build();
    }

    @DeleteMapping("/api/articles")
    public ResponseEntity<Article> delete() {
        Article deleted = articleService.alldelete();
        return (deleted != null) ? ResponseEntity.status(HttpStatus.NO_CONTENT).build() :
        ResponseEntity.status(HttpStatus.BAD_REQUEST).build();
    }


    //트랜잭션 -> 실패 -> 롤백!
    @PostMapping("/api/transaction-test")
    public ResponseEntity<List<Article>> transactionTest(@RequestBody List<ArticleForm> dtos) {
        List<Article> createdList = articleService.createArticles(dtos);
        return (createdList != null) ?
                ResponseEntity.status(HttpStatus.OK).body(createdList) :
                ResponseEntity.status(HttpStatus.BAD_REQUEST).build();

    }
}
